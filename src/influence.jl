"""
    MixedModelBootstrap{T<:AbstractFloat} <: MixedModelFitCollection{T}

Object returned by `parametericbootstrap` with fields
- `fits`: the parameter estimates from the bootstrap replicates as a vector of named tuples.
- `λ`: `Vector{LowerTriangular{T,Matrix{T}}}` containing copies of the λ field from `ReMat` model terms
- `inds`: `Vector{Vector{Int}}` containing copies of the `inds` field from `ReMat` model terms
- `lowerbd`: `Vector{T}` containing the vector of lower bounds (corresponds to the identically named field of [`OptSummary`](@ref))
- `fcnames`: NamedTuple whose keys are the grouping factor names and whose values are the column names
The schema of `fits` is, by default,
```
Tables.Schema:
 :objective  T
 :σ          T
 :β          NamedTuple{β_names}{NTuple{p,T}}
 :se         StaticArrays.SArray{Tuple{p},T,1,p}
 :θ          StaticArrays.SArray{Tuple{k},T,1,k}
```
where the sizes, `p` and `k`, of the `β` and `θ` elements are determined by the model.
Characteristics of the bootstrap replicates can be extracted as properties.  The `σs` and
`σρs` properties unravel the `σ` and `θ` estimates into estimates of the standard deviations
and correlations of the random-effects terms.
"""

#struct Influence{T} MixedModels.MixedModelFitCollection{T<:AbstractFloat}}
# fits::Vector
# λ::Vector{Union{LowerTriangular{T},Diagonal{T}}}
# inds::Vector{Vector{Int}}
# lowerbd::Vector{T}
# fcnames::NamedTuple
#end


function influence(model::LinearMixedModel) end

function influence(model::LinearMixedModel, group::AbstractString)
    return influence(model, Symbol(group))
end

function influence(model::LinearMixedModel, group::Symbol) end

# while the API here is inspired by influnece.ME and the results
# are tested against reference values, this is a clean implementation
# without looking at the associated source

function exclude_influence(model::LinearMixedModel, obs_idx)
end


#   •  trm: the grouping factor as a StatsModels.CategoricalTerm
#   •  refs: indices into the levels of the grouping factor as a Vector{Int32}
#   •  levels: the levels of the grouping factor
#   •  cnames: the names of the columns of the model matrix generated by the left-hand side of the term
#   •  z: transpose of the model matrix generated by the left-hand side of the term
#   •  wtz: a weighted copy of z (z and wtz are the same object for unweighted cases)
#   •  λ: a LowerTriangular matrix of size S×S
#   •  inds: a Vector{Int} of linear indices of the potential nonzeros in λ
#   •  adjA: the adjoint of the matrix as a SparseMatrixCSC{T}
#   •  scratch: a Matrix{T}
function exclude_influence(model::LinearMixedModel, group::Symbol, level)
    re_idx = findfirst(model.reterms) do x
        return Symbol(x.trm) == group
    end
    isnothing(re_idx) && throw(ArgumentError("$group is not a grouping term in the model"))

    re = model.reterms[re_idx]
    level_ref = findfirst(==(level), re.levels)
    isnothing(level_ref) && throw(ArgumentError("$level is not a level of $group in the model"))
    nc = length(re.cnames)
    col_idx = [1:((level_ref-1)*nc); (level_ref*nc+1):(nc*length(re.levels))]
    row_idx = re.refs .!= level_ref
    newre = typeof(re)(re.trm,
                       re.refs[row_idx],
                       re.levels[re.levels .!= level],
                       re.cnames,
                       re.z[:, row_idx],
                       re.wtz[:, row_idx],
                       copy(re.λ),
                       copy(re.inds),
                       re.adjA[col_idx, row_idx],
                       re.scratch[:, 1:(length(re.levels)-1)])
    Xs = AbstractMatrix[model.X[row_idx, :]]
    for i in 1:length(model.reterms)
        if i == re_idx
            push!(Xs, newre)
        else
            push!(Xs, deepcopy(model.reterms[i]))
        end
    end
    lmm = LinearMixedModel(model.y[row_idx], Tuple(Xs), model.formula,
                           abs2.(model.sqrtwts), model.σ)
    return fit!(lmm)
end